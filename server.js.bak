const express = require('express');
const http = require('http');
const socketIo = require('socket.io');
const cors = require('cors');
const path = require('path');
const sqlite3 = require('sqlite3').verbose();
const { open } = require('sqlite');
const crypto = require('crypto');

const app = express();
const server = http.createServer(app);

// Configuration CORS adaptative
const corsOrigins = process.env.NODE_ENV === 'production'
  ? ['https://libekoo.me', 'https://www.libekoo.me']
  : ['http://localhost:5173', 'http://localhost:3000'];

const io = socketIo(server, {
  cors: {
    origin: corsOrigins,
    methods: ['GET', 'POST'],
    credentials: true
  },
  pingInterval: 10000,
  pingTimeout: 5000
});

// Middleware
app.use(cors({
  origin: corsOrigins,
  credentials: true
}));
app.use(express.json({ limit: '10mb' }));

// Servir les fichiers statiques en production
if (process.env.NODE_ENV === 'production') {
  app.use(express.static(path.join(__dirname, 'dist')));
}

// ==========================================
// BASE DE DONNÉES SQLite
// ==========================================
let db;

async function initDatabase() {
  db = await open({
    filename: './libekoo.db',
    driver: sqlite3.Database
  });

  // Tables de base
  await db.exec(`
    CREATE TABLE IF NOT EXISTS users (
      id TEXT PRIMARY KEY,
      username TEXT NOT NULL,
      socket_id TEXT,
      is_anonymous BOOLEAN DEFAULT 1,
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      last_seen DATETIME DEFAULT CURRENT_TIMESTAMP
    );

    CREATE TABLE IF NOT EXISTS chat_sessions (
      id TEXT PRIMARY KEY,
      user1_id TEXT NOT NULL,
      user2_id TEXT NOT NULL,
      status TEXT DEFAULT 'active',
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      ended_at DATETIME,
      FOREIGN KEY (user1_id) REFERENCES users(id),
      FOREIGN KEY (user2_id) REFERENCES users(id)
    );

    CREATE TABLE IF NOT EXISTS messages (
      id TEXT PRIMARY KEY,
      session_id TEXT NOT NULL,
      user_id TEXT NOT NULL,
      message TEXT NOT NULL,
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      FOREIGN KEY (session_id) REFERENCES chat_sessions(id),
      FOREIGN KEY (user_id) REFERENCES users(id)
    );

    CREATE INDEX IF NOT EXISTS idx_messages_session ON messages(session_id);
    CREATE INDEX IF NOT EXISTS idx_sessions_users ON chat_sessions(user1_id, user2_id);
    CREATE INDEX IF NOT EXISTS idx_users_socket ON users(socket_id);
  `);

  console.log('✅ Base de données initialisée');
}

// ==========================================
// STOCKAGE IN-MEMORY (Cache)
// ==========================================
const activeUsers = new Map(); // socketId -> userId
const waitingQueues = {
  chat: [],
  video: [],
  group: []
};

// ==========================================
// FONCTIONS UTILITAIRES
// ==========================================
const generateId = (prefix = 'id') => {
  return `${prefix}_${Date.now()}_${crypto.randomBytes(4).toString('hex')}`;
};

const sanitizeMessage = (message) => {
  if (!message || typeof message !== 'string') return '';
  // Limite la taille et supprime les caractères dangereux
  return message.slice(0, 1000).replace(/[<>]/g, '');
};

// ==========================================
// GESTION DES UTILISATEURS
// ==========================================
async function createUser(socketId, username) {
  const userId = generateId('user');
  const safeUsername = username || `Anonyme_${Math.floor(Math.random() * 9999)}`;
  
  await db.run(
    'INSERT INTO users (id, username, socket_id, is_anonymous) VALUES (?, ?, ?, ?)',
    [userId, safeUsername, socketId, !username]
  );
  
  activeUsers.set(socketId, userId);
  return { id: userId, username: safeUsername, isAnonymous: !username };
}

async function updateUserSocket(userId, socketId) {
  await db.run(
    'UPDATE users SET socket_id = ?, last_seen = CURRENT_TIMESTAMP WHERE id = ?',
    [socketId, userId]
  );
  activeUsers.set(socketId, userId);
}

async function disconnectUser(socketId) {
  const userId = activeUsers.get(socketId);
  if (userId) {
    await db.run(
      'UPDATE users SET socket_id = NULL, last_seen = CURRENT_TIMESTAMP WHERE id = ?',
      [userId]
    );
    
    // Retirer des files d'attente
    Object.keys(waitingQueues).forEach(type => {
      waitingQueues[type] = waitingQueues[type].filter(id => id !== userId);
    });
    
    activeUsers.delete(socketId);
  }
}

// ==========================================
// GESTION DES SESSIONS DE CHAT
// ==========================================
async function createChatSession(user1Id, user2Id) {
  const sessionId = generateId('session');
  
  await db.run(
    'INSERT INTO chat_sessions (id, user1_id, user2_id) VALUES (?, ?, ?)',
    [sessionId, user1Id, user2Id]
  );
  
  return sessionId;
}

async function endChatSession(sessionId) {
  await db.run(
    'UPDATE chat_sessions SET status = ?, ended_at = CURRENT_TIMESTAMP WHERE id = ?',
    ['ended', sessionId]
  );
}

async function saveMessage(sessionId, userId, message) {
  const messageId = generateId('msg');
  const safeMessage = sanitizeMessage(message);
  
  await db.run(
    'INSERT INTO messages (id, session_id, user_id, message) VALUES (?, ?, ?, ?)',
    [messageId, sessionId, userId, safeMessage]
  );
  
  return { id: messageId, message: safeMessage, timestamp: new Date() };
}

async function getSessionMessages(sessionId, limit = 100) {
  return await db.all(
    `SELECT m.*, u.username 
     FROM messages m 
     JOIN users u ON m.user_id = u.id 
     WHERE m.session_id = ? 
     ORDER BY m.created_at DESC 
     LIMIT ?`,
    [sessionId, limit]
  );
}

// ==========================================
// MATCHING ALGORITHM
// ==========================================
async function attemptMatch(type, userId) {
  if (type !== 'chat') return null; // Pour l'instant, seulement le chat
  
  const queue = waitingQueues[type];
  const userIndex = queue.indexOf(userId);
  
  if (userIndex === -1 || queue.length < 2) return null;
  
  // Trouve un partenaire (premier disponible différent)
  for (let i = 0; i < queue.length; i++) {
    if (i !== userIndex) {
      const partnerId = queue[i];
      
      // Créer la session
      const sessionId = await createChatSession(userId, partnerId);
      
      // Retirer de la file
      waitingQueues[type] = queue.filter(id => id !== userId && id !== partnerId);
      
      return { sessionId, partnerId };
    }
  }
  
  return null;
}

// ==========================================
// SOCKET.IO EVENTS
// ==========================================
io.on('connection', (socket) => {
  console.log('✅ Client connecté:', socket.id);
  
  // Enregistrement utilisateur
  socket.on('user:register', async (userData, callback) => {
    try {
      const user = await createUser(socket.id, userData.username);
      callback({ success: true, user });
    } catch (error) {
      console.error('Erreur inscription:', error);
      callback({ success: false, error: 'Erreur lors de l\'inscription' });
    }
  });

  // Rejoindre une file d'attente
  socket.on('queue:join', async ({ type, userId }, callback) => {
    try {
      if (!['chat', 'video', 'group'].includes(type)) {
        throw new Error('Type invalide');
      }
      
      // Nettoyer les anciennes présences
      Object.keys(waitingQueues).forEach(queueType => {
        waitingQueues[queueType] = waitingQueues[queueType].filter(id => id !== userId);
      });
      
      // Ajouter à la nouvelle file
      waitingQueues[type].push(userId);
      
      callback({ success: true });
      
      // Tenter un match immédiatement
      const match = await attemptMatch(type, userId);
      if (match) {
        // Obtenir les infos des deux utilisateurs
        const user1 = await db.get('SELECT * FROM users WHERE id = ?', userId);
        const user2 = await db.get('SELECT * FROM users WHERE id = ?', match.partnerId);
        
        // Notifier les deux utilisateurs
        if (user1?.socket_id) {
          io.to(user1.socket_id).emit('match:found', {
            sessionId: match.sessionId,
            partner: { id: match.partnerId, username: user2?.username || 'Anonyme' }
          });
        }
        
        if (user2?.socket_id) {
          io.to(user2.socket_id).emit('match:found', {
            sessionId: match.sessionId,
            partner: { id: userId, username: user1?.username || 'Anonyme' }
          });
        }
      }
    } catch (error) {
      console.error('Erreur queue:join:', error);
      callback({ success: false, error: error.message });
    }
  });

  // Quitter la file
  socket.on('queue:leave', ({ userId }, callback) => {
    try {
      Object.keys(waitingQueues).forEach(type => {
        waitingQueues[type] = waitingQueues[type].filter(id => id !== userId);
      });
      callback({ success: true });
    } catch (error) {
      callback({ success: false, error: error.message });
    }
  });

  // Envoyer un message
  socket.on('message:send', async ({ sessionId, userId, message }, callback) => {
    try {
      // Vérifier la session
      const session = await db.get(
        'SELECT * FROM chat_sessions WHERE id = ? AND status = ?',
        [sessionId, 'active']
      );
      
      if (!session) {
        throw new Error('Session invalide ou terminée');
      }
      
      // Sauvegarder le message
      const savedMessage = await saveMessage(sessionId, userId, message);
      
      // Obtenir l'autre utilisateur
      const otherId = session.user1_id === userId ? session.user2_id : session.user1_id;
      const otherUser = await db.get('SELECT * FROM users WHERE id = ?', otherId);
      const sender = await db.get('SELECT * FROM users WHERE id = ?', userId);
      
      // Envoyer au destinataire
      if (otherUser?.socket_id) {
        io.to(otherUser.socket_id).emit('message:receive', {
          id: savedMessage.id,
          userId,
          username: sender?.username || 'Anonyme',
          message: savedMessage.message,
          timestamp: savedMessage.timestamp,
          isOwn: false
        });
      }
      
      callback({ success: true, messageId: savedMessage.id });
    } catch (error) {
      console.error('Erreur message:send:', error);
      callback({ success: false, error: error.message });
    }
  });

  // Passer au suivant
  socket.on('chat:skip', async ({ sessionId, userId }, callback) => {
    try {
      await endChatSession(sessionId);
      
      // Notifier l'autre utilisateur
      const session = await db.get('SELECT * FROM chat_sessions WHERE id = ?', sessionId);
      if (session) {
        const otherId = session.user1_id === userId ? session.user2_id : session.user1_id;
        const otherUser = await db.get('SELECT * FROM users WHERE id = ?', otherId);
        
        if (otherUser?.socket_id) {
          io.to(otherUser.socket_id).emit('session:ended', { sessionId });
        }
      }
      
      // Remettre en file d'attente
      waitingQueues.chat.push(userId);
      callback({ success: true });
      
      // Tenter un nouveau match après un délai
      setTimeout(() => attemptMatch('chat', userId), 1000);
    } catch (error) {
      callback({ success: false, error: error.message });
    }
  });

  // Récupérer l'historique
  socket.on('messages:history', async ({ sessionId }, callback) => {
    try {
      const messages = await getSessionMessages(sessionId);
      callback({ success: true, messages: messages.reverse() });
    } catch (error) {
      callback({ success: false, error: error.message });
    }
  });

  // Déconnexion
  socket.on('disconnect', async () => {
    console.log('❌ Client déconnecté:', socket.id);
    await disconnectUser(socket.id);
  });
});

// ==========================================
// ROUTES API REST
// ==========================================
app.get('/api/health', (req, res) => {
  res.json({ 
    status: 'ok', 
    timestamp: new Date(),
    environment: process.env.NODE_ENV || 'development'
  });
});

app.get('/api/queue-status', (req, res) => {
  res.json({
    chat: waitingQueues.chat.length,
    video: waitingQueues.video.length,
    group: waitingQueues.group.length
  });
});

// Route SPA en production
if (process.env.NODE_ENV === 'production') {
  app.get('*', (req, res) => {
    res.sendFile(path.join(__dirname, 'dist', 'index.html'));
  });
}

// ==========================================
// DÉMARRAGE DU SERVEUR
// ==========================================
const PORT = process.env.PORT || 3000;
const HOST = '0.0.0.0';

async function startServer() {
  try {
    await initDatabase();
    
    server.listen(PORT, HOST, () => {
      console.log(`🚀 Serveur démarré sur ${HOST}:${PORT}`);
      console.log(`📡 Socket.io prêt`);
      console.log(`🌍 Environnement: ${process.env.NODE_ENV || 'development'}`);
    });
  } catch (error) {
    console.error('❌ Erreur de démarrage:', error);
    process.exit(1);
  }
}

startServer();

// Gestion propre de l'arrêt
process.on('SIGTERM', async () => {
  console.log('Arrêt du serveur...');
  if (db) await db.close();
  server.close(() => process.exit(0));
});